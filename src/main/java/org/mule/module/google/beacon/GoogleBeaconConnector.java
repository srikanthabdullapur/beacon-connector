/**
 * Mule Google Beacon Cloud Connector
 *
 * Copyright (c) MuleSoft, Inc.  All rights reserved.  http://www.mulesoft.com
 *
 * The software in this package is published under the terms of the CPAL v1.0
 * license, a copy of which has been included with this distribution in the
 * LICENSE.txt file.
 */

/**
 * This file was automatically generated by the Mule Development Kit
 */
package org.mule.module.google.beacon;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.Map;

import org.apache.log4j.Logger;
import org.mule.api.annotations.Configurable;
import org.mule.api.annotations.Connector;
import org.mule.api.annotations.Processor;
import org.mule.api.annotations.ReconnectOn;
import org.mule.api.annotations.lifecycle.Start;
import org.mule.api.annotations.oauth.OAuth2;
import org.mule.api.annotations.oauth.OAuthAccessToken;
import org.mule.api.annotations.oauth.OAuthAuthorizationParameter;
import org.mule.api.annotations.oauth.OAuthConsumerKey;
import org.mule.api.annotations.oauth.OAuthConsumerSecret;
import org.mule.api.annotations.oauth.OAuthPostAuthorization;
import org.mule.api.annotations.oauth.OAuthProtected;
import org.mule.api.annotations.oauth.OAuthScope;
import org.mule.api.annotations.param.Default;
import org.mule.api.annotations.param.Optional;
import org.mule.module.google.beacon.model.AdvertisedId;
import org.mule.module.google.beacon.model.Beacon;
import org.mule.module.google.beacon.model.BeaconAttachment;
import org.mule.module.google.beacon.model.IndoorLevel;
import org.mule.module.google.beacon.model.LatLng;
import org.mule.module.google.beacon.transformer.BatchResponseToBulkOperationTransformer;
import org.mule.modules.google.AbstractGoogleOAuthConnector;
import org.mule.modules.google.AccessType;
import org.mule.modules.google.ForcePrompt;
import org.mule.modules.google.GoogleUserIdExtractor;
import org.mule.modules.google.oauth.invalidation.OAuthTokenExpiredException;

import com.google.api.services.proximitybeacon.Proximitybeacon;
import com.google.gson.Gson;

/**
 * Google Beacon Cloud connector. This connector covers almost all the Google
 * Calendar API v3 using OAuth2 for authentication.
 *
 * @author MuleSoft, Inc.
 */
@Connector(name = "google-beacon", schemaVersion = "1.0", friendlyName = "Google Beacon", minMuleVersion = "3.5", configElementName = "config-with-oauth")
@OAuth2(authorizationUrl = "https://accounts.google.com/o/oauth2/auth", accessTokenUrl = "https://accounts.google.com/o/oauth2/token", accessTokenRegex = "\"access_token\"[ ]*:[ ]*\"([^\\\"]*)\"", expirationRegex = "\"expires_in\"[ ]*:[ ]*([\\d]*)", refreshTokenRegex = "\"refresh_token\"[ ]*:[ ]*\"([^\\\"]*)\"", authorizationParameters = {
		@OAuthAuthorizationParameter(name = "access_type", defaultValue = "online", type = AccessType.class, description = "Indicates if your application needs to access a Google API when the user is not present at the browser. "
				+ " Use offline to get a refresh token and use that when the user is not at the browser. Default is online", optional = true),
		@OAuthAuthorizationParameter(name = "force_prompt", defaultValue = "auto", type = ForcePrompt.class, description = "Indicates if google should remember that an app has been authorized or if each should ask authorization every time. "
				+ " Use force to request authorization every time or auto to only do it the first time. Default is auto", optional = true) }, friendlyName = "")
@ReconnectOn(exceptions = OAuthTokenExpiredException.class)
public class GoogleBeaconConnector extends AbstractGoogleOAuthConnector implements Constants {
	private static final Logger LOGGER = Logger.getLogger(GoogleBeaconConnector.class);
	/**
	 * The OAuth2 consumer key
	 */
	@Configurable
	@OAuthConsumerKey
	private String consumerKey;

	/**
	 * The OAuth2 consumer secret
	 */
	@Configurable
	@OAuthConsumerSecret
	private String consumerSecret;

	/**
	 * Application name registered on Google API console
	 */
	@Configurable
	@Default("Mule-GoogleCalendarConnector/1.0")
	private String applicationName;

	/**
	 * The OAuth scopes you want to request
	 */
	@OAuthScope
	@Configurable
	@Default(USER_PROFILE_SCOPE	+" "+ BEACON_REGISTRY_SCOPE)
	private String scope;

	/**
	 * Factory to instantiate the underlying google client. Usually you don't
	 * need to override this. Most common use case of a custom value here is
	 * testing.
	 */
	@Configurable
	@Optional
	private GoogleBeaconClientFactory clientFactory;

	@OAuthAccessToken
	private String accessToken;

	/**
	 * The google api client
	 */
	private Proximitybeacon client;

	/**
	 * Initializes the connector. if no clientFactory was provided, then a
	 * default
	 * {@link org.mule.module.google.beacon.DefaultGoogleBeaconClientFactory}
	 * wil be used instead
	 */
	@Start
	public void init() {
		if (this.clientFactory == null) {
			this.clientFactory = new DefaultGoogleBeaconClientFactory();
		}
		this.registerTransformer(new BatchResponseToBulkOperationTransformer());
	}

	@OAuthPostAuthorization
	public void postAuth() throws Exception {
		this.client = this.clientFactory.newClient(this.getAccessToken(),
				this.getApplicationName());
		GoogleUserIdExtractor.fetchAndPublishAsFlowVar(this);
	}

	@Processor
	@OAuthProtected
	public String listAttachments(String beaconName) throws IOException {
		String url = PROXIMITY_URL+ beaconName + LIST_ATTACHMENTS;
		String response = connectGetURL(url);
		return response;
	}

	
	@Processor
	@OAuthProtected
	public String registerBeacon(@Default("#[payload]") Beacon beacon,
			@Optional @Default("EDDYSTONE") String advertisedIdType,
			String advertisedIdValue,
			@Optional @Default("ACTIVE") String status,
			@Optional String placeId, @Optional Double lat,
			@Optional Double lng, @Optional String indoorLevel,
			@Optional String expectedStability, @Optional String description,
			@Optional Map<String, String> properties) throws IOException {

		String url = REGISTER_BEACON_URL;
		// beacon object getting
		Beacon beaconJson = new Beacon();
		AdvertisedId paramAdvertisedId = new AdvertisedId();
		paramAdvertisedId.setType(advertisedIdType);
		paramAdvertisedId.setId(advertisedIdValue);
		beaconJson.setAdvertisedId(paramAdvertisedId);
		beaconJson.setStatus(status);
		if (placeId != null) {
			beaconJson.setPlaceId(placeId);
		}
		if (lat != null && lng != null) {
			LatLng paramLatLng = new LatLng();
			paramLatLng.setLatitude(lat);
			paramLatLng.setLongitude(lng);
			beaconJson.setLatLng(paramLatLng);
		}
		if (indoorLevel != null) {
			IndoorLevel paramIndoorLevel = new IndoorLevel();
			paramIndoorLevel.setName(indoorLevel);
			beaconJson.setIndoorLevel(paramIndoorLevel);
		}
		if (expectedStability != null) {
			beaconJson.setExpectedStability(expectedStability);
		}
		if (description != null) {
			beaconJson.setDescription(description);
		}
		if (properties != null) {
			beaconJson.setProperties(properties);
		}
		Gson gson = new Gson();
		String requestBody = gson.toJson(beaconJson.wrapped()).toString();
		LOGGER.info("requset body-----------" + requestBody);
		String response = connectPostUrlRB(url, requestBody);
		return response;
	}

	@Processor
	@OAuthProtected
	public String activateBeacon(String beaconName) throws IOException {
		String url = PROXIMITY_URL + beaconName + ACTIVATE_BEACON;
		Object response = connectPostURL(url);
		return "Activated successfully";

	}

	@Processor
	@OAuthProtected
	public String deactivateBeacon(String beaconName) throws IOException {
		String url = PROXIMITY_URL + beaconName + DEACTIVATE_BEACON;
		Object response = connectPostURL(url);
		return "Deactivated successfully";
	}

	@Processor
	@OAuthProtected
	public String decommissionBeacon(String beaconName) throws IOException {
		String url = PROXIMITY_URL + beaconName + DECOMMISSION_BEACON;
		Object response = connectPostURL(url);
		return "Decommission successfully";
	}

	@Processor
	@OAuthProtected
	public String getBeaconInfo(String beaconName) throws IOException {
		LOGGER.info("beaconName-------------" + beaconName);
		LOGGER.info("accessToken-------------" + accessToken);
		String url = PROXIMITY_URL + beaconName;
		String response = connectGetURL(url);
		return response;
	}

	@Processor
	@OAuthProtected
	public String getBeacons() throws IOException {
		String url = GET_BEACON_URL;
		String response = connectGetURL(url);
		return response;
	}

	@Processor
	@OAuthProtected
	public String listBeacons(String query) throws IOException {
		String url = QUERY_BEACON_URL + query;
		String response = connectGetURL(url);
		return response;
	}

	@Processor
	@OAuthProtected
	public String updateBeacon(@Default("#[payload]") Beacon beacon,
			@Optional @Default("EDDYSTONE") String advertisedIdType,
			String advertisedIdValue,
			@Optional @Default("ACTIVE") String status,
			@Optional String placeId, @Optional Double lat,
			@Optional Double lng, @Optional String indoorLevel,
			@Optional String expectedStability, @Optional String description,
			@Optional Map<String, String> properties, String beaconName)
			throws IOException {
		String url = PROXIMITY_URL + beaconName;
		// beacon object getting
		Beacon beaconJson = new Beacon();
		AdvertisedId paramAdvertisedId = new AdvertisedId();
		paramAdvertisedId.setType(advertisedIdType);
		paramAdvertisedId.setId(advertisedIdValue);
		beaconJson.setAdvertisedId(paramAdvertisedId);
		beaconJson.setStatus(status);
		if (placeId != null) {
			beaconJson.setPlaceId(placeId);
		}
		if (lat != null && lng != null) {
			LatLng paramLatLng = new LatLng();
			paramLatLng.setLatitude(lat);
			paramLatLng.setLongitude(lng);
			beaconJson.setLatLng(paramLatLng);
		}
		if (indoorLevel != null) {
			IndoorLevel paramIndoorLevel = new IndoorLevel();
			paramIndoorLevel.setName(indoorLevel);
			beaconJson.setIndoorLevel(paramIndoorLevel);
		}
		if (expectedStability != null) {
			beaconJson.setExpectedStability(expectedStability);
		}
		if (description != null) {
			beaconJson.setDescription(description);
		}
		if (properties != null) {
			beaconJson.setProperties(properties);
		}
		Gson gson = new Gson();
		String requestBody = gson.toJson(beaconJson.wrapped()).toString();
		LOGGER.info("requset body-----------" + requestBody);
		String response = connectPutUrlRB(url, requestBody);
		return response;
	}

	@Processor
	@OAuthProtected
	public String createAttachment(String beaconName,
			@Default("#[payload]") BeaconAttachment attachment, String data,
			String ProjectId, @Default("String") String dataType)
			throws IOException {
		String url = PROXIMITY_URL + beaconName + LIST_ATTACHMENTS;
		BeaconAttachment beaconAttchment = new BeaconAttachment();
		String paramString = ProjectId + "/" + dataType;
		beaconAttchment.setNamespacedType(paramString);
		beaconAttchment.setData(data);
		Gson gson = new Gson();
		String requestBody = gson.toJson(beaconAttchment.wrapped()).toString();
		LOGGER.info("requset body-----------" + requestBody);
		String response = connectPostUrlRB(url, requestBody);
		return response.toString();
	}

	// todo
	@Processor
	@OAuthProtected
	public String batchDeleteAttachments(String beaconName) throws IOException {
		String url = PROXIMITY_URL + beaconName + BATCH_DELETE_ATTACHMENTS;
		Object response = connectDeleteURL(url);
		return response.toString();
	}

	@Processor
	@OAuthProtected
	public String deleteAttachment(String beaconName, String attachmentId)
			throws IOException {
		String attachmentName = beaconName + ATTACHMENTS + attachmentId;
		String url = PROXIMITY_URL + attachmentName;
		Object response = connectDeleteURL(url);
		return "Deleted Attachment:" + attachmentId;
	}

	/*
	 * @Processor
	 * 
	 * @OAuthProtected public String getBeacons() throws IOException { String
	 * url =
	 * "https://proximitybeacon.googleapis.com/v1beta1/beaconinfo:getforobserved"
	 * ; String requestBody = ""; String response = connectPostUrlRB(url,
	 * requestBody); return response; }
	 */

	public String connectGetURL(String url) throws IOException {
		URL obj = new URL(url);
		HttpURLConnection con = (HttpURLConnection) obj.openConnection();
		con.addRequestProperty(AUTHORIZATION, BEARER + accessToken);
		con.setRequestMethod(GET);
		con.setRequestProperty(USER_AGENT, MOZILLA);
		con.setRequestProperty(ACCEPT, "*/*");
		int responseCode = con.getResponseCode();
		LOGGER.info("\nSending 'GET' request to URL : " + url);
		LOGGER.info("Response Code : " + responseCode);
		BufferedReader in = new BufferedReader(new InputStreamReader(
				con.getInputStream()));
		String inputLine;
		StringBuffer response = new StringBuffer();
		while ((inputLine = in.readLine()) != null) {
			response.append(inputLine);
		}
		in.close();
		LOGGER.info(response.toString());
		return response.toString();

	}

	// POST for empty request body
	public String connectPostURL(String url) throws IOException {
		URL obj = new URL(url);
		HttpURLConnection con = (HttpURLConnection) obj.openConnection();
		con.addRequestProperty(AUTHORIZATION, BEARER + accessToken);
		con.setRequestMethod(POST);
		con.setRequestProperty(USER_AGENT, MOZILLA);
		con.setRequestProperty(CONTENT_TYPE, "text/xml");
		con.setRequestProperty(CONTENT_LENGTH, "0");
		con.setDoOutput(true);
		String POST_PARAMS = "";
		OutputStream os = con.getOutputStream();
		os.write(POST_PARAMS.getBytes());
		os.flush();
		os.close();
		con.connect();
		LOGGER.info("\nSending 'POST' request to URL : " + url);
		BufferedReader in = new BufferedReader(new InputStreamReader(
				con.getInputStream()));
		String inputLine;
		StringBuffer response = new StringBuffer();
		while ((inputLine = in.readLine()) != null) {
			response.append(inputLine);
		}
		in.close();
		return response.toString();
	}

	// POST with request body
	public String connectPostUrlRB(String url, String requestBody)
			throws IOException {
		URL obj = new URL(url);
		HttpURLConnection con = (HttpURLConnection) obj.openConnection();
		con.addRequestProperty(AUTHORIZATION, BEARER + accessToken);
		con.setRequestMethod(POST);
		con.setRequestProperty(USER_AGENT, MOZILLA);
		con.setRequestProperty(CONTENT_TYPE, "application/json");
		con.setDoOutput(true);
		String POST_PARAMS = requestBody;
		OutputStream os = con.getOutputStream();
		os.write(POST_PARAMS.getBytes());
		os.flush();
		os.close();
		con.connect();
		LOGGER.info("\nSending 'POST' request to URL : " + url);
		BufferedReader in = new BufferedReader(new InputStreamReader(
				con.getInputStream()));
		String inputLine;
		StringBuffer response = new StringBuffer();
		while ((inputLine = in.readLine()) != null) {
			response.append(inputLine);
		}
		in.close();
		return response.toString();
	}

	// POST with request body
	public String connectPutUrlRB(String url, String requestBody)
			throws IOException {
		URL obj = new URL(url);
		HttpURLConnection con = (HttpURLConnection) obj.openConnection();
		con.addRequestProperty(AUTHORIZATION, BEARER + accessToken);
		con.setRequestMethod(PUT);
		con.setRequestProperty(USER_AGENT, MOZILLA);
		con.setRequestProperty(CONTENT_TYPE, "application/json");
		con.setDoOutput(true);
		String POST_PARAMS = requestBody;
		OutputStream os = con.getOutputStream();
		os.write(POST_PARAMS.getBytes());
		os.flush();
		os.close();
		con.connect();
		LOGGER.info("\nSending 'PUT' request to URL : " + url);
		BufferedReader in = new BufferedReader(new InputStreamReader(
				con.getInputStream()));
		String inputLine;
		StringBuffer response = new StringBuffer();
		while ((inputLine = in.readLine()) != null) {
			response.append(inputLine);
		}
		in.close();
		return response.toString();
	}

	public String connectDeleteURL(String url) throws IOException {
		URL obj = new URL(url);
		HttpURLConnection con = (HttpURLConnection) obj.openConnection();
		con.addRequestProperty(AUTHORIZATION, BEARER + accessToken);
		con.setRequestMethod(DELETE);
		con.setRequestProperty(USER_AGENT, MOZILLA);
		con.setRequestProperty(ACCEPT, "*/*");
		int responseCode = con.getResponseCode();
		LOGGER.info("\nSending 'DELETE' request to URL : " + url);
		LOGGER.info("Response Code : " + responseCode);
		BufferedReader in = new BufferedReader(new InputStreamReader(
				con.getInputStream()));
		String inputLine;
		StringBuffer response = new StringBuffer();
		while ((inputLine = in.readLine()) != null) {
			response.append(inputLine);
		}
		in.close();
		LOGGER.info(response.toString());
		return response.toString();

	}

	/*
	 * { "attachmentName": string, "namespacedType": string, "data": string, }
	 */
	public String constructBeaconAttachment(String attachmentName) {
		return null;

	}

	public String getScope() {
		return scope;
	}

	public void setScope(String scope) {
		this.scope = scope;
	}

	public String getConsumerKey() {
		return consumerKey;
	}

	public void setConsumerKey(String consumerKey) {
		this.consumerKey = consumerKey;
	}

	public String getConsumerSecret() {
		return consumerSecret;
	}

	public void setConsumerSecret(String consumerSecret) {
		this.consumerSecret = consumerSecret;
	}

	public String getApplicationName() {
		return applicationName;
	}

	public void setApplicationName(String applicationName) {
		this.applicationName = applicationName;
	}

	@Override
	public String getAccessToken() {
		return accessToken;
	}

	public void setAccessToken(String accessToken) {
		this.accessToken = accessToken;
	}

	public GoogleBeaconClientFactory getClientFactory() {
		return clientFactory;
	}

	public void setClientFactory(GoogleBeaconClientFactory clientFactory) {
		this.clientFactory = clientFactory;
	}

	@Override
	public Object getClient() {
		return this.client;
	}

}
